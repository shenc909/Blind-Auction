pragma solidity >0.4.23 <0.6.0;
import "../Dns.sol";
import "./MockBlindAuction.sol";

contract MockDns is Dns {
    struct MockAuctionItem {
        MockBlindAuction auction;
        address addr;
        uint256 bidding_end;
    }

    mapping(string => MockAuctionItem) private auctions;

    constructor(
        uint256 bidding_len,
        uint256 reveal_len,
        uint256 exp
    ) public Dns(bidding_len, reveal_len, exp) {}

    function testFuncParam(int256 input_int) public pure returns (int256) {
        return input_int;
    }

    function testFunc() public pure returns (string memory) {
        return ("teststring.ntu");
    }

    function testRegisterFunc(string memory url, address addr) public {
        if (checkExpired(url)) {
            internalAddressRegister(url, addr);
            emit Registration(addr, url, expiry_date[url]);
        } else {
            emit Registration(address(0), "not expired", 0);
        }
    }

    function startMockAuction(string memory url) public {
        if (!checkExpired(url)) {
            revert("URL not yet expired!");
        }

        if (!checkAuctionEnded(url)) {
            revert("Existing auction not yet ended!");
        }

        AuctionItem memory new_auction;
        // Init new auction here
        new_auction.auction = createMockAuction(url);
        new_auction.addr = address(new_auction.auction);
        new_auction.bidding_end = new_auction.auction.biddingEnd();
        auctions[url] = new_auction;
        // emit AuctionStart(new_auction.addr, url);
    }

    function createMockAuction(string memory url)
        private
        returns (MockBlindAuction)
    {
        BlindAuction auction = new MockBlindAuction(
            bidding_length,
            reveal_length,
            url,
            address(uint160(address(this))),
            msg.sender
        );
        return auction;
    }
}
